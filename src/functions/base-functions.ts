import { MosaiaConfig } from '../types';
import APIClient from '../utils/api-client';
import { ConfigurationManager } from '../config';

/**
 * Base functions class that provides common functionality for all function classes
 * 
 * This abstract class serves as the foundation for all API function classes in the SDK.
 * It provides standardized CRUD operations, configuration management, and error handling
 * that can be extended by specific function implementations.
 * 
 * @template T - The interface type for the entity (e.g., UserInterface, AgentInterface)
 * @template GetPayload - The payload type for GET responses (e.g., GetUsersPayload)
 * @template CreatePayload - The payload type for POST/PUT responses (e.g., GetUserPayload)
 * 
 * @example
 * ```typescript
 * class Users extends BaseFunctions<UserInterface, GetUsersPayload, GetUserPayload> {
 *   constructor() {
 *     super('/user');
 *   }
 * }
 * 
 * const users = new Users();
 * const allUsers = await users.get();
 * const newUser = await users.create({ email: 'john@example.com' });
 * ```
 * 
 * @category Functions
 */
export abstract class BaseFunctions<T extends object = any, GetPayload = any, CreatePayload = any> {
    protected apiClient: APIClient;
    protected configManager: ConfigurationManager;
    protected uri: string = '';

    constructor(uri?: string) {
        this.configManager = ConfigurationManager.getInstance();
        // Create API client (uses ConfigurationManager internally)
        this.apiClient = new APIClient();
        if (uri) this.uri = uri;
    }

    /**
     * Get the current configuration from the ConfigurationManager
     * 
     * This getter provides access to the current SDK configuration,
     * including API keys, URLs, and other settings.
     * 
     * @returns The current MosaiaConfig object
     * 
     * @example
     * ```typescript
     * const currentConfig = this.config;
     * console.log('API URL:', currentConfig.apiURL);
     * console.log('API Key:', currentConfig.apiKey);
     * ```
     */
    protected get config(): MosaiaConfig {
        return this.configManager.getConfig();
    }

    /**
     * Get entities with optional filtering and pagination
     * 
     * This method retrieves entities from the API. When called without an ID,
     * it returns a list of entities with optional filtering and pagination.
     * When called with an ID, it returns a specific entity.
     * 
     * @param params - Optional query parameters for filtering and pagination
     * @param params.limit - Maximum number of items to return
     * @param params.offset - Number of items to skip (for pagination)
     * @param params.q - Search query for text-based filtering
     * @param params.active - Filter by active status
     * @param params.tags - Array of tags to filter by
     * @param id - Optional specific entity ID to retrieve
     * @returns Promise that resolves to the entity data
     * 
     * @example
     * ```typescript
     * // Get all entities
     * const allEntities = await functions.get();
     * 
     * // Get entities with filtering
     * const filteredEntities = await functions.get({
     *   limit: 10,
     *   offset: 0,
     *   q: 'search term',
     *   active: true
     * });
     * 
     * // Get specific entity by ID
     * const entity = await functions.get({}, 'entity-id');
     * ```
     * 
     * @throws {Error} When API request fails
     */
    async get(params?: object, id?: string): Promise<GetPayload> {
        try {
            let uri = this.uri;
            if (id) uri = `${uri}/${id}`;
            
            return this.apiClient.GET<GetPayload>(uri, params);
        } catch (error) {
            throw this.handleError(error);
        }
    }

    /**
     * Create a new entity
     * 
     * This method creates a new entity in the system. The entity ID will be
     * automatically generated by the server.
     * 
     * @param entity - Entity data for the new entity (ID will be generated)
     * @param entity.id - Optional ID (will be ignored, server generates ID)
     * @param entity.active - Whether the entity should be active
     * @param entity.external_id - External system identifier
     * @param entity.extensors - Extended properties for custom integrations
     * @param params - Optional query parameters to include in the request
     * @returns Promise that resolves to the created entity
     * 
     * @example
     * ```typescript
     * // Create a new user
     * const newUser = await users.create({
     *   email: 'john@example.com',
     *   firstName: 'John',
     *   lastName: 'Doe',
     *   active: true
     * });
     * 
     * // Create with external ID
     * const newAgent = await agents.create({
     *   name: 'My Agent',
     *   shortDescription: 'A helpful AI agent',
     *   external_id: 'agent-123',
     *   extensors: {
     *     customField: 'custom value'
     *   }
     * });
     * ```
     * 
     * @throws {Error} When API request fails or validation fails
     */
    async create(entity: T, params?: object): Promise<CreatePayload> {
        try {
            let uri = this.uri;

            if (params) uri += `?${new URLSearchParams(params as any).toString()}`;
            return this.apiClient.POST<CreatePayload>(uri, entity);
        } catch (error) {
            throw this.handleError(error);
        }
    }

    /**
     * Update an existing entity
     * 
     * This method updates an existing entity in the system. Only the fields
     * provided in the entity parameter will be updated.
     * 
     * @param id - The entity ID to update
     * @param entity - Entity data for the update (only provided fields will be updated)
     * @param entity.active - Whether the entity should be active
     * @param entity.external_id - External system identifier
     * @param entity.extensors - Extended properties for custom integrations
     * @param params - Optional query parameters to include in the request
     * @returns Promise that resolves to the updated entity
     * 
     * @example
     * ```typescript
     * // Update user's email
     * const updatedUser = await users.update('user-id', {
     *   email: 'newemail@example.com'
     * });
     * 
     * // Update multiple fields
     * const updatedAgent = await agents.update('agent-id', {
     *   name: 'Updated Agent Name',
     *   shortDescription: 'Updated description',
     *   active: false
     * });
     * 
     * // Update with external ID
     * const updatedOrg = await organizations.update('org-id', {
     *   name: 'New Organization Name',
     *   external_id: 'new-external-id'
     * });
     * ```
     * 
     * @throws {Error} When API request fails, entity not found, or validation fails
     */
    async update(id: string, entity: Partial<T>, params?: object): Promise<CreatePayload> {
        try {
            let uri = `${this.uri}/${id}`;

            if (params) uri += `?${new URLSearchParams(params as any).toString()}`;
            return this.apiClient.PUT<CreatePayload>(uri, entity);
        } catch (error) {
            throw this.handleError(error);
        }
    }

    /**
     * Delete an entity
     * 
     * This method permanently deletes an entity from the system. This action
     * cannot be undone, so use with caution.
     * 
     * @param id - The entity ID to delete
     * @param params - Optional query parameters (e.g., force deletion flags)
     * @param params.force - Force deletion even if entity has dependencies
     * @returns Promise that resolves when deletion is successful
     * 
     * @example
     * ```typescript
     * // Delete a user
     * await users.delete('user-id');
     * 
     * // Force delete an organization
     * await organizations.delete('org-id', { force: true });
     * 
     * // Delete with additional parameters
     * await agents.delete('agent-id', { 
     *   force: true,
     *   cascade: true 
     * });
     * ```
     * 
     * @throws {Error} When API request fails, entity not found, or deletion is not allowed
     */
    async delete(id: string, params?: object): Promise<void> {
        try {
            let uri = `${this.uri}/${id}`;

            if (params) uri += `?${new URLSearchParams(params as any).toString()}`;
            await this.apiClient.DELETE<void>(uri, params);
        } catch (error) {
            throw this.handleError(error);
        }
    }

    /**
     * Handle API errors consistently across all function classes
     * 
     * This protected method provides standardized error handling for all
     * API operations. It ensures that errors are properly formatted and
     * contain meaningful messages.
     * 
     * @param error - The error to handle (can be any type)
     * @returns Standardized Error object with a meaningful message
     * 
     * @example
     * ```typescript
     * try {
     *   const result = await this.apiClient.GET('/endpoint');
     *   return result;
     * } catch (error) {
     *   throw this.handleError(error);
     * }
     * ```
     * 
     * @throws {Error} Always throws a standardized Error object
     */
    protected handleError(error: any): Error {
        if ((error as any).message) {
            return error;
        }
        
        if (typeof error === 'object' && error.message) {
            return new Error(error.message);
        }
        
        return new Error('Unknown error occurred');
    }
} 